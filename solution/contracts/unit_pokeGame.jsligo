#import "./pokeGame.jsligo" "PokeGame"

export type main_fn = module_contract<parameter_of PokeGame, PokeGame.storage>;

// reset state

const _ = Test.reset_state(2 as nat, list([]) as list<tez>);

const faucet = Test.nth_bootstrap_account(0);

const sender1: address = Test.nth_bootstrap_account(1);

const _2 = Test.log("Sender 1 has balance : ");

const _3 = Test.log(Test.get_balance(sender1));

const _4 = Test.set_baker(faucet);

const _5 = Test.set_source(faucet);

const initial_storage = {
  pokeTraces: Map.empty as map<address, PokeGame.pokeMessage>,
  feedback: "kiss"
};

const initial_tez = 0 as tez;

//functions

export const _testPoke = (
  taddr: typed_address<parameter_of PokeGame, PokeGame.storage>,
  s: address
): unit => {
  //contract origination
  //const [taddr, _, _] = Test.originate_module(contract_of(PokeGame),  {pokeTraces : Map.empty as map<address, PokeGame.pokeMessage> , feedback : "kiss"}, 0 as tez);

  const contr = Test.to_contract(taddr);
  const contrAddress = Tezos.address(contr);
  Test.log("contract deployed with values : ");
  Test.log(contr);
  Test.set_source(s);
  const status = Test.transfer_to_contract(contr, Poke, 0 as tez);
/*
  Test.log(status);
  const store: PokeGame.storage = Test.get_storage(taddr);
  Test.log(store);
  //check poke is registered

  match(Map.find_opt(s, store.pokeTraces)) {
    when (Some(pokeMessage)): do {
        assert_with_error(
          pokeMessage.feedback == "",
          "feedback " + pokeMessage.feedback + " is not equal to expected "
          + "(empty)"
        );
        assert_with_error(
          pokeMessage.receiver == contrAddress,
          "receiver is not equal"
        );
      }
    when (None):
      () => assert_with_error(false, "don't find traces")
  };*/

};

// TESTS //

const testSender1Poke =
  (
    (): unit => {
      const [taddr, _, _2] =
        Test.originate_module(
          contract_of(PokeGame),
          initial_storage,
          initial_tez
        );
      _testPoke(taddr, sender1);
    }
  )();
